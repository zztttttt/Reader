///
/// JHybridRnIapSpec.cpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2026 Marc Rousavy @ Margelo
///

#include "JHybridRnIapSpec.hpp"

// Forward declaration of `NitroProduct` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroProduct; }
// Forward declaration of `IapPlatform` to properly resolve imports.
namespace margelo::nitro::iap { enum class IapPlatform; }
// Forward declaration of `PaymentModeIOS` to properly resolve imports.
namespace margelo::nitro::iap { enum class PaymentModeIOS; }
// Forward declaration of `NitroOneTimePurchaseOfferDetail` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroOneTimePurchaseOfferDetail; }
// Forward declaration of `NitroDiscountDisplayInfoAndroid` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroDiscountDisplayInfoAndroid; }
// Forward declaration of `NitroDiscountAmountAndroid` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroDiscountAmountAndroid; }
// Forward declaration of `NitroLimitedQuantityInfoAndroid` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroLimitedQuantityInfoAndroid; }
// Forward declaration of `NitroPreorderDetailsAndroid` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroPreorderDetailsAndroid; }
// Forward declaration of `NitroRentalDetailsAndroid` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroRentalDetailsAndroid; }
// Forward declaration of `NitroValidTimeWindowAndroid` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroValidTimeWindowAndroid; }
// Forward declaration of `PurchaseAndroid` to properly resolve imports.
namespace margelo::nitro::iap { struct PurchaseAndroid; }
// Forward declaration of `PurchaseIOS` to properly resolve imports.
namespace margelo::nitro::iap { struct PurchaseIOS; }
// Forward declaration of `PurchaseState` to properly resolve imports.
namespace margelo::nitro::iap { enum class PurchaseState; }
// Forward declaration of `IapStore` to properly resolve imports.
namespace margelo::nitro::iap { enum class IapStore; }
// Forward declaration of `PurchaseOfferIOS` to properly resolve imports.
namespace margelo::nitro::iap { struct PurchaseOfferIOS; }
// Forward declaration of `RenewalInfoIOS` to properly resolve imports.
namespace margelo::nitro::iap { struct RenewalInfoIOS; }
// Forward declaration of `NitroPurchase` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroPurchase; }
// Forward declaration of `NitroRenewalInfoIOS` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroRenewalInfoIOS; }
// Forward declaration of `NitroActiveSubscription` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroActiveSubscription; }
// Forward declaration of `NitroPurchaseResult` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroPurchaseResult; }
// Forward declaration of `NitroSubscriptionStatus` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroSubscriptionStatus; }
// Forward declaration of `NitroSubscriptionRenewalInfo` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroSubscriptionRenewalInfo; }
// Forward declaration of `NitroReceiptValidationResultIOS` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroReceiptValidationResultIOS; }
// Forward declaration of `NitroReceiptValidationResultAndroid` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroReceiptValidationResultAndroid; }
// Forward declaration of `NitroVerifyPurchaseWithProviderResult` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroVerifyPurchaseWithProviderResult; }
// Forward declaration of `NitroVerifyPurchaseWithIapkitResult` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroVerifyPurchaseWithIapkitResult; }
// Forward declaration of `IapkitPurchaseState` to properly resolve imports.
namespace margelo::nitro::iap { enum class IapkitPurchaseState; }
// Forward declaration of `NitroVerifyPurchaseWithProviderError` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroVerifyPurchaseWithProviderError; }
// Forward declaration of `PurchaseVerificationProvider` to properly resolve imports.
namespace margelo::nitro::iap { enum class PurchaseVerificationProvider; }
// Forward declaration of `NitroBillingProgramAvailabilityResultAndroid` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroBillingProgramAvailabilityResultAndroid; }
// Forward declaration of `BillingProgramAndroid` to properly resolve imports.
namespace margelo::nitro::iap { enum class BillingProgramAndroid; }
// Forward declaration of `NitroBillingProgramReportingDetailsAndroid` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroBillingProgramReportingDetailsAndroid; }
// Forward declaration of `ExternalPurchaseNoticeResultIOS` to properly resolve imports.
namespace margelo::nitro::iap { struct ExternalPurchaseNoticeResultIOS; }
// Forward declaration of `ExternalPurchaseNoticeAction` to properly resolve imports.
namespace margelo::nitro::iap { enum class ExternalPurchaseNoticeAction; }
// Forward declaration of `ExternalPurchaseLinkResultIOS` to properly resolve imports.
namespace margelo::nitro::iap { struct ExternalPurchaseLinkResultIOS; }
// Forward declaration of `InitConnectionConfig` to properly resolve imports.
namespace margelo::nitro::iap { struct InitConnectionConfig; }
// Forward declaration of `AlternativeBillingModeAndroid` to properly resolve imports.
namespace margelo::nitro::iap { enum class AlternativeBillingModeAndroid; }
// Forward declaration of `NitroPurchaseRequest` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroPurchaseRequest; }
// Forward declaration of `NitroRequestPurchaseIos` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroRequestPurchaseIos; }
// Forward declaration of `NitroRequestPurchaseAndroid` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroRequestPurchaseAndroid; }
// Forward declaration of `AndroidSubscriptionOfferInput` to properly resolve imports.
namespace margelo::nitro::iap { struct AndroidSubscriptionOfferInput; }
// Forward declaration of `NitroAvailablePurchasesOptions` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroAvailablePurchasesOptions; }
// Forward declaration of `NitroAvailablePurchasesIosOptions` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroAvailablePurchasesIosOptions; }
// Forward declaration of `NitroAvailablePurchasesAndroidOptions` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroAvailablePurchasesAndroidOptions; }
// Forward declaration of `NitroAvailablePurchasesAndroidType` to properly resolve imports.
namespace margelo::nitro::iap { enum class NitroAvailablePurchasesAndroidType; }
// Forward declaration of `NitroFinishTransactionParams` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroFinishTransactionParams; }
// Forward declaration of `NitroFinishTransactionIosParams` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroFinishTransactionIosParams; }
// Forward declaration of `NitroFinishTransactionAndroidParams` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroFinishTransactionAndroidParams; }
// Forward declaration of `NitroReceiptValidationParams` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroReceiptValidationParams; }
// Forward declaration of `NitroReceiptValidationAppleOptions` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroReceiptValidationAppleOptions; }
// Forward declaration of `NitroReceiptValidationGoogleOptions` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroReceiptValidationGoogleOptions; }
// Forward declaration of `NitroReceiptValidationHorizonOptions` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroReceiptValidationHorizonOptions; }
// Forward declaration of `NitroVerifyPurchaseWithProviderProps` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroVerifyPurchaseWithProviderProps; }
// Forward declaration of `NitroVerifyPurchaseWithIapkitProps` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroVerifyPurchaseWithIapkitProps; }
// Forward declaration of `NitroVerifyPurchaseWithIapkitAppleProps` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroVerifyPurchaseWithIapkitAppleProps; }
// Forward declaration of `NitroVerifyPurchaseWithIapkitGoogleProps` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroVerifyPurchaseWithIapkitGoogleProps; }
// Forward declaration of `NitroDeepLinkOptionsAndroid` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroDeepLinkOptionsAndroid; }
// Forward declaration of `UserChoiceBillingDetails` to properly resolve imports.
namespace margelo::nitro::iap { struct UserChoiceBillingDetails; }
// Forward declaration of `DeveloperProvidedBillingDetailsAndroid` to properly resolve imports.
namespace margelo::nitro::iap { struct DeveloperProvidedBillingDetailsAndroid; }
// Forward declaration of `NitroLaunchExternalLinkParamsAndroid` to properly resolve imports.
namespace margelo::nitro::iap { struct NitroLaunchExternalLinkParamsAndroid; }
// Forward declaration of `ExternalLinkLaunchModeAndroid` to properly resolve imports.
namespace margelo::nitro::iap { enum class ExternalLinkLaunchModeAndroid; }
// Forward declaration of `ExternalLinkTypeAndroid` to properly resolve imports.
namespace margelo::nitro::iap { enum class ExternalLinkTypeAndroid; }

#include <NitroModules/Promise.hpp>
#include <NitroModules/JPromise.hpp>
#include "NitroProduct.hpp"
#include <vector>
#include "JNitroProduct.hpp"
#include <string>
#include <optional>
#include "IapPlatform.hpp"
#include "JIapPlatform.hpp"
#include "PaymentModeIOS.hpp"
#include "JPaymentModeIOS.hpp"
#include "NitroOneTimePurchaseOfferDetail.hpp"
#include "JNitroOneTimePurchaseOfferDetail.hpp"
#include "NitroDiscountDisplayInfoAndroid.hpp"
#include "JNitroDiscountDisplayInfoAndroid.hpp"
#include "NitroDiscountAmountAndroid.hpp"
#include "JNitroDiscountAmountAndroid.hpp"
#include "NitroLimitedQuantityInfoAndroid.hpp"
#include "JNitroLimitedQuantityInfoAndroid.hpp"
#include "NitroPreorderDetailsAndroid.hpp"
#include "JNitroPreorderDetailsAndroid.hpp"
#include "NitroRentalDetailsAndroid.hpp"
#include "JNitroRentalDetailsAndroid.hpp"
#include "NitroValidTimeWindowAndroid.hpp"
#include "JNitroValidTimeWindowAndroid.hpp"
#include "PurchaseAndroid.hpp"
#include "PurchaseIOS.hpp"
#include <variant>
#include "JRequestPurchaseResult.hpp"
#include "JPurchaseAndroid.hpp"
#include "PurchaseState.hpp"
#include "JPurchaseState.hpp"
#include "IapStore.hpp"
#include "JIapStore.hpp"
#include "JPurchaseIOS.hpp"
#include "PurchaseOfferIOS.hpp"
#include "JPurchaseOfferIOS.hpp"
#include "RenewalInfoIOS.hpp"
#include "JRenewalInfoIOS.hpp"
#include "JPurchase.hpp"
#include "NitroPurchase.hpp"
#include "JNitroPurchase.hpp"
#include "NitroRenewalInfoIOS.hpp"
#include "JNitroRenewalInfoIOS.hpp"
#include "NitroActiveSubscription.hpp"
#include "JNitroActiveSubscription.hpp"
#include "NitroPurchaseResult.hpp"
#include "JVariant_Boolean_NitroPurchaseResult.hpp"
#include "JNitroPurchaseResult.hpp"
#include "NitroSubscriptionStatus.hpp"
#include "JNitroSubscriptionStatus.hpp"
#include "NitroSubscriptionRenewalInfo.hpp"
#include "JNitroSubscriptionRenewalInfo.hpp"
#include "NitroReceiptValidationResultIOS.hpp"
#include "NitroReceiptValidationResultAndroid.hpp"
#include "JVariant_NitroReceiptValidationResultIOS_NitroReceiptValidationResultAndroid.hpp"
#include "JNitroReceiptValidationResultIOS.hpp"
#include "JNitroReceiptValidationResultAndroid.hpp"
#include "NitroVerifyPurchaseWithProviderResult.hpp"
#include "JNitroVerifyPurchaseWithProviderResult.hpp"
#include "NitroVerifyPurchaseWithIapkitResult.hpp"
#include "JNitroVerifyPurchaseWithIapkitResult.hpp"
#include "IapkitPurchaseState.hpp"
#include "JIapkitPurchaseState.hpp"
#include "NitroVerifyPurchaseWithProviderError.hpp"
#include "JNitroVerifyPurchaseWithProviderError.hpp"
#include "PurchaseVerificationProvider.hpp"
#include "JPurchaseVerificationProvider.hpp"
#include "NitroBillingProgramAvailabilityResultAndroid.hpp"
#include "JNitroBillingProgramAvailabilityResultAndroid.hpp"
#include "BillingProgramAndroid.hpp"
#include "JBillingProgramAndroid.hpp"
#include "NitroBillingProgramReportingDetailsAndroid.hpp"
#include "JNitroBillingProgramReportingDetailsAndroid.hpp"
#include "ExternalPurchaseNoticeResultIOS.hpp"
#include "JExternalPurchaseNoticeResultIOS.hpp"
#include "ExternalPurchaseNoticeAction.hpp"
#include "JExternalPurchaseNoticeAction.hpp"
#include "ExternalPurchaseLinkResultIOS.hpp"
#include "JExternalPurchaseLinkResultIOS.hpp"
#include "InitConnectionConfig.hpp"
#include "JInitConnectionConfig.hpp"
#include "AlternativeBillingModeAndroid.hpp"
#include "JAlternativeBillingModeAndroid.hpp"
#include "NitroPurchaseRequest.hpp"
#include "JNitroPurchaseRequest.hpp"
#include "NitroRequestPurchaseIos.hpp"
#include "JNitroRequestPurchaseIos.hpp"
#include <unordered_map>
#include "NitroRequestPurchaseAndroid.hpp"
#include "JNitroRequestPurchaseAndroid.hpp"
#include "AndroidSubscriptionOfferInput.hpp"
#include "JAndroidSubscriptionOfferInput.hpp"
#include "NitroAvailablePurchasesOptions.hpp"
#include "JNitroAvailablePurchasesOptions.hpp"
#include "NitroAvailablePurchasesIosOptions.hpp"
#include "JNitroAvailablePurchasesIosOptions.hpp"
#include "NitroAvailablePurchasesAndroidOptions.hpp"
#include "JNitroAvailablePurchasesAndroidOptions.hpp"
#include "NitroAvailablePurchasesAndroidType.hpp"
#include "JNitroAvailablePurchasesAndroidType.hpp"
#include "NitroFinishTransactionParams.hpp"
#include "JNitroFinishTransactionParams.hpp"
#include "NitroFinishTransactionIosParams.hpp"
#include "JNitroFinishTransactionIosParams.hpp"
#include "NitroFinishTransactionAndroidParams.hpp"
#include "JNitroFinishTransactionAndroidParams.hpp"
#include <functional>
#include "JFunc_void_NitroPurchase.hpp"
#include "JFunc_void_NitroPurchaseResult.hpp"
#include "JFunc_void_NitroProduct.hpp"
#include "NitroReceiptValidationParams.hpp"
#include "JNitroReceiptValidationParams.hpp"
#include "NitroReceiptValidationAppleOptions.hpp"
#include "JNitroReceiptValidationAppleOptions.hpp"
#include "NitroReceiptValidationGoogleOptions.hpp"
#include "JNitroReceiptValidationGoogleOptions.hpp"
#include "NitroReceiptValidationHorizonOptions.hpp"
#include "JNitroReceiptValidationHorizonOptions.hpp"
#include "NitroVerifyPurchaseWithProviderProps.hpp"
#include "JNitroVerifyPurchaseWithProviderProps.hpp"
#include "NitroVerifyPurchaseWithIapkitProps.hpp"
#include "JNitroVerifyPurchaseWithIapkitProps.hpp"
#include "NitroVerifyPurchaseWithIapkitAppleProps.hpp"
#include "JNitroVerifyPurchaseWithIapkitAppleProps.hpp"
#include "NitroVerifyPurchaseWithIapkitGoogleProps.hpp"
#include "JNitroVerifyPurchaseWithIapkitGoogleProps.hpp"
#include "NitroDeepLinkOptionsAndroid.hpp"
#include "JNitroDeepLinkOptionsAndroid.hpp"
#include "UserChoiceBillingDetails.hpp"
#include "JFunc_void_UserChoiceBillingDetails.hpp"
#include "JUserChoiceBillingDetails.hpp"
#include "DeveloperProvidedBillingDetailsAndroid.hpp"
#include "JFunc_void_DeveloperProvidedBillingDetailsAndroid.hpp"
#include "JDeveloperProvidedBillingDetailsAndroid.hpp"
#include "NitroLaunchExternalLinkParamsAndroid.hpp"
#include "JNitroLaunchExternalLinkParamsAndroid.hpp"
#include "ExternalLinkLaunchModeAndroid.hpp"
#include "JExternalLinkLaunchModeAndroid.hpp"
#include "ExternalLinkTypeAndroid.hpp"
#include "JExternalLinkTypeAndroid.hpp"

namespace margelo::nitro::iap {

  jni::local_ref<JHybridRnIapSpec::jhybriddata> JHybridRnIapSpec::initHybrid(jni::alias_ref<jhybridobject> jThis) {
    return makeCxxInstance(jThis);
  }

  void JHybridRnIapSpec::registerNatives() {
    registerHybrid({
      makeNativeMethod("initHybrid", JHybridRnIapSpec::initHybrid),
    });
  }

  size_t JHybridRnIapSpec::getExternalMemorySize() noexcept {
    static const auto method = javaClassStatic()->getMethod<jlong()>("getMemorySize");
    return method(_javaPart);
  }

  void JHybridRnIapSpec::dispose() noexcept {
    static const auto method = javaClassStatic()->getMethod<void()>("dispose");
    method(_javaPart);
  }

  // Properties
  

  // Methods
  std::shared_ptr<Promise<bool>> JHybridRnIapSpec::initConnection(const std::optional<InitConnectionConfig>& config) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>(jni::alias_ref<JInitConnectionConfig> /* config */)>("initConnection");
    auto __result = method(_javaPart, config.has_value() ? JInitConnectionConfig::fromCpp(config.value()) : nullptr);
    return [&]() {
      auto __promise = Promise<bool>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<jni::JBoolean>(__boxedResult);
        __promise->resolve(static_cast<bool>(__result->value()));
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<bool>> JHybridRnIapSpec::endConnection() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>()>("endConnection");
    auto __result = method(_javaPart);
    return [&]() {
      auto __promise = Promise<bool>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<jni::JBoolean>(__boxedResult);
        __promise->resolve(static_cast<bool>(__result->value()));
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<std::vector<NitroProduct>>> JHybridRnIapSpec::fetchProducts(const std::vector<std::string>& skus, const std::string& type) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>(jni::alias_ref<jni::JArrayClass<jni::JString>> /* skus */, jni::alias_ref<jni::JString> /* type */)>("fetchProducts");
    auto __result = method(_javaPart, [&]() {
      size_t __size = skus.size();
      jni::local_ref<jni::JArrayClass<jni::JString>> __array = jni::JArrayClass<jni::JString>::newArray(__size);
      for (size_t __i = 0; __i < __size; __i++) {
        const auto& __element = skus[__i];
        __array->setElement(__i, *jni::make_jstring(__element));
      }
      return __array;
    }(), jni::make_jstring(type));
    return [&]() {
      auto __promise = Promise<std::vector<NitroProduct>>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<jni::JArrayClass<JNitroProduct>>(__boxedResult);
        __promise->resolve([&]() {
          size_t __size = __result->size();
          std::vector<NitroProduct> __vector;
          __vector.reserve(__size);
          for (size_t __i = 0; __i < __size; __i++) {
            auto __element = __result->getElement(__i);
            __vector.push_back(__element->toCpp());
          }
          return __vector;
        }());
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<std::optional<std::variant<PurchaseAndroid, PurchaseIOS, std::vector<std::variant<PurchaseAndroid, PurchaseIOS>>>>>> JHybridRnIapSpec::requestPurchase(const NitroPurchaseRequest& request) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>(jni::alias_ref<JNitroPurchaseRequest> /* request */)>("requestPurchase");
    auto __result = method(_javaPart, JNitroPurchaseRequest::fromCpp(request));
    return [&]() {
      auto __promise = Promise<std::optional<std::variant<PurchaseAndroid, PurchaseIOS, std::vector<std::variant<PurchaseAndroid, PurchaseIOS>>>>>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<JRequestPurchaseResult>(__boxedResult);
        __promise->resolve(__result != nullptr ? std::make_optional(__result->toCpp()) : std::nullopt);
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<std::vector<NitroPurchase>>> JHybridRnIapSpec::getAvailablePurchases(const std::optional<NitroAvailablePurchasesOptions>& options) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>(jni::alias_ref<JNitroAvailablePurchasesOptions> /* options */)>("getAvailablePurchases");
    auto __result = method(_javaPart, options.has_value() ? JNitroAvailablePurchasesOptions::fromCpp(options.value()) : nullptr);
    return [&]() {
      auto __promise = Promise<std::vector<NitroPurchase>>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<jni::JArrayClass<JNitroPurchase>>(__boxedResult);
        __promise->resolve([&]() {
          size_t __size = __result->size();
          std::vector<NitroPurchase> __vector;
          __vector.reserve(__size);
          for (size_t __i = 0; __i < __size; __i++) {
            auto __element = __result->getElement(__i);
            __vector.push_back(__element->toCpp());
          }
          return __vector;
        }());
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<std::vector<NitroActiveSubscription>>> JHybridRnIapSpec::getActiveSubscriptions(const std::optional<std::vector<std::string>>& subscriptionIds) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>(jni::alias_ref<jni::JArrayClass<jni::JString>> /* subscriptionIds */)>("getActiveSubscriptions");
    auto __result = method(_javaPart, subscriptionIds.has_value() ? [&]() {
      size_t __size = subscriptionIds.value().size();
      jni::local_ref<jni::JArrayClass<jni::JString>> __array = jni::JArrayClass<jni::JString>::newArray(__size);
      for (size_t __i = 0; __i < __size; __i++) {
        const auto& __element = subscriptionIds.value()[__i];
        __array->setElement(__i, *jni::make_jstring(__element));
      }
      return __array;
    }() : nullptr);
    return [&]() {
      auto __promise = Promise<std::vector<NitroActiveSubscription>>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<jni::JArrayClass<JNitroActiveSubscription>>(__boxedResult);
        __promise->resolve([&]() {
          size_t __size = __result->size();
          std::vector<NitroActiveSubscription> __vector;
          __vector.reserve(__size);
          for (size_t __i = 0; __i < __size; __i++) {
            auto __element = __result->getElement(__i);
            __vector.push_back(__element->toCpp());
          }
          return __vector;
        }());
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<bool>> JHybridRnIapSpec::hasActiveSubscriptions(const std::optional<std::vector<std::string>>& subscriptionIds) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>(jni::alias_ref<jni::JArrayClass<jni::JString>> /* subscriptionIds */)>("hasActiveSubscriptions");
    auto __result = method(_javaPart, subscriptionIds.has_value() ? [&]() {
      size_t __size = subscriptionIds.value().size();
      jni::local_ref<jni::JArrayClass<jni::JString>> __array = jni::JArrayClass<jni::JString>::newArray(__size);
      for (size_t __i = 0; __i < __size; __i++) {
        const auto& __element = subscriptionIds.value()[__i];
        __array->setElement(__i, *jni::make_jstring(__element));
      }
      return __array;
    }() : nullptr);
    return [&]() {
      auto __promise = Promise<bool>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<jni::JBoolean>(__boxedResult);
        __promise->resolve(static_cast<bool>(__result->value()));
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<std::variant<bool, NitroPurchaseResult>>> JHybridRnIapSpec::finishTransaction(const NitroFinishTransactionParams& params) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>(jni::alias_ref<JNitroFinishTransactionParams> /* params */)>("finishTransaction");
    auto __result = method(_javaPart, JNitroFinishTransactionParams::fromCpp(params));
    return [&]() {
      auto __promise = Promise<std::variant<bool, NitroPurchaseResult>>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<JVariant_Boolean_NitroPurchaseResult>(__boxedResult);
        __promise->resolve(__result->toCpp());
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  void JHybridRnIapSpec::addPurchaseUpdatedListener(const std::function<void(const NitroPurchase& /* purchase */)>& listener) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JFunc_void_NitroPurchase::javaobject> /* listener */)>("addPurchaseUpdatedListener_cxx");
    method(_javaPart, JFunc_void_NitroPurchase_cxx::fromCpp(listener));
  }
  void JHybridRnIapSpec::addPurchaseErrorListener(const std::function<void(const NitroPurchaseResult& /* error */)>& listener) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JFunc_void_NitroPurchaseResult::javaobject> /* listener */)>("addPurchaseErrorListener_cxx");
    method(_javaPart, JFunc_void_NitroPurchaseResult_cxx::fromCpp(listener));
  }
  void JHybridRnIapSpec::removePurchaseUpdatedListener(const std::function<void(const NitroPurchase& /* purchase */)>& listener) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JFunc_void_NitroPurchase::javaobject> /* listener */)>("removePurchaseUpdatedListener_cxx");
    method(_javaPart, JFunc_void_NitroPurchase_cxx::fromCpp(listener));
  }
  void JHybridRnIapSpec::removePurchaseErrorListener(const std::function<void(const NitroPurchaseResult& /* error */)>& listener) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JFunc_void_NitroPurchaseResult::javaobject> /* listener */)>("removePurchaseErrorListener_cxx");
    method(_javaPart, JFunc_void_NitroPurchaseResult_cxx::fromCpp(listener));
  }
  void JHybridRnIapSpec::addPromotedProductListenerIOS(const std::function<void(const NitroProduct& /* product */)>& listener) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JFunc_void_NitroProduct::javaobject> /* listener */)>("addPromotedProductListenerIOS_cxx");
    method(_javaPart, JFunc_void_NitroProduct_cxx::fromCpp(listener));
  }
  void JHybridRnIapSpec::removePromotedProductListenerIOS(const std::function<void(const NitroProduct& /* product */)>& listener) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JFunc_void_NitroProduct::javaobject> /* listener */)>("removePromotedProductListenerIOS_cxx");
    method(_javaPart, JFunc_void_NitroProduct_cxx::fromCpp(listener));
  }
  std::shared_ptr<Promise<std::string>> JHybridRnIapSpec::getStorefrontIOS() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>()>("getStorefrontIOS");
    auto __result = method(_javaPart);
    return [&]() {
      auto __promise = Promise<std::string>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<jni::JString>(__boxedResult);
        __promise->resolve(__result->toStdString());
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<std::optional<std::string>>> JHybridRnIapSpec::getAppTransactionIOS() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>()>("getAppTransactionIOS");
    auto __result = method(_javaPart);
    return [&]() {
      auto __promise = Promise<std::optional<std::string>>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<jni::JString>(__boxedResult);
        __promise->resolve(__result != nullptr ? std::make_optional(__result->toStdString()) : std::nullopt);
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<std::optional<NitroProduct>>> JHybridRnIapSpec::requestPromotedProductIOS() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>()>("requestPromotedProductIOS");
    auto __result = method(_javaPart);
    return [&]() {
      auto __promise = Promise<std::optional<NitroProduct>>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<JNitroProduct>(__boxedResult);
        __promise->resolve(__result != nullptr ? std::make_optional(__result->toCpp()) : std::nullopt);
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<std::optional<NitroProduct>>> JHybridRnIapSpec::getPromotedProductIOS() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>()>("getPromotedProductIOS");
    auto __result = method(_javaPart);
    return [&]() {
      auto __promise = Promise<std::optional<NitroProduct>>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<JNitroProduct>(__boxedResult);
        __promise->resolve(__result != nullptr ? std::make_optional(__result->toCpp()) : std::nullopt);
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<void>> JHybridRnIapSpec::buyPromotedProductIOS() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>()>("buyPromotedProductIOS");
    auto __result = method(_javaPart);
    return [&]() {
      auto __promise = Promise<void>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& /* unit */) {
        __promise->resolve();
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<bool>> JHybridRnIapSpec::presentCodeRedemptionSheetIOS() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>()>("presentCodeRedemptionSheetIOS");
    auto __result = method(_javaPart);
    return [&]() {
      auto __promise = Promise<bool>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<jni::JBoolean>(__boxedResult);
        __promise->resolve(static_cast<bool>(__result->value()));
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<void>> JHybridRnIapSpec::clearTransactionIOS() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>()>("clearTransactionIOS");
    auto __result = method(_javaPart);
    return [&]() {
      auto __promise = Promise<void>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& /* unit */) {
        __promise->resolve();
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<std::optional<std::string>>> JHybridRnIapSpec::beginRefundRequestIOS(const std::string& sku) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>(jni::alias_ref<jni::JString> /* sku */)>("beginRefundRequestIOS");
    auto __result = method(_javaPart, jni::make_jstring(sku));
    return [&]() {
      auto __promise = Promise<std::optional<std::string>>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<jni::JString>(__boxedResult);
        __promise->resolve(__result != nullptr ? std::make_optional(__result->toStdString()) : std::nullopt);
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<std::optional<std::vector<NitroSubscriptionStatus>>>> JHybridRnIapSpec::subscriptionStatusIOS(const std::string& sku) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>(jni::alias_ref<jni::JString> /* sku */)>("subscriptionStatusIOS");
    auto __result = method(_javaPart, jni::make_jstring(sku));
    return [&]() {
      auto __promise = Promise<std::optional<std::vector<NitroSubscriptionStatus>>>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<jni::JArrayClass<JNitroSubscriptionStatus>>(__boxedResult);
        __promise->resolve(__result != nullptr ? std::make_optional([&]() {
          size_t __size = __result->size();
          std::vector<NitroSubscriptionStatus> __vector;
          __vector.reserve(__size);
          for (size_t __i = 0; __i < __size; __i++) {
            auto __element = __result->getElement(__i);
            __vector.push_back(__element->toCpp());
          }
          return __vector;
        }()) : std::nullopt);
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<std::optional<NitroPurchase>>> JHybridRnIapSpec::currentEntitlementIOS(const std::string& sku) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>(jni::alias_ref<jni::JString> /* sku */)>("currentEntitlementIOS");
    auto __result = method(_javaPart, jni::make_jstring(sku));
    return [&]() {
      auto __promise = Promise<std::optional<NitroPurchase>>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<JNitroPurchase>(__boxedResult);
        __promise->resolve(__result != nullptr ? std::make_optional(__result->toCpp()) : std::nullopt);
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<std::optional<NitroPurchase>>> JHybridRnIapSpec::latestTransactionIOS(const std::string& sku) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>(jni::alias_ref<jni::JString> /* sku */)>("latestTransactionIOS");
    auto __result = method(_javaPart, jni::make_jstring(sku));
    return [&]() {
      auto __promise = Promise<std::optional<NitroPurchase>>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<JNitroPurchase>(__boxedResult);
        __promise->resolve(__result != nullptr ? std::make_optional(__result->toCpp()) : std::nullopt);
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<std::vector<NitroPurchase>>> JHybridRnIapSpec::getPendingTransactionsIOS() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>()>("getPendingTransactionsIOS");
    auto __result = method(_javaPart);
    return [&]() {
      auto __promise = Promise<std::vector<NitroPurchase>>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<jni::JArrayClass<JNitroPurchase>>(__boxedResult);
        __promise->resolve([&]() {
          size_t __size = __result->size();
          std::vector<NitroPurchase> __vector;
          __vector.reserve(__size);
          for (size_t __i = 0; __i < __size; __i++) {
            auto __element = __result->getElement(__i);
            __vector.push_back(__element->toCpp());
          }
          return __vector;
        }());
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<bool>> JHybridRnIapSpec::syncIOS() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>()>("syncIOS");
    auto __result = method(_javaPart);
    return [&]() {
      auto __promise = Promise<bool>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<jni::JBoolean>(__boxedResult);
        __promise->resolve(static_cast<bool>(__result->value()));
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<std::vector<NitroPurchase>>> JHybridRnIapSpec::showManageSubscriptionsIOS() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>()>("showManageSubscriptionsIOS");
    auto __result = method(_javaPart);
    return [&]() {
      auto __promise = Promise<std::vector<NitroPurchase>>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<jni::JArrayClass<JNitroPurchase>>(__boxedResult);
        __promise->resolve([&]() {
          size_t __size = __result->size();
          std::vector<NitroPurchase> __vector;
          __vector.reserve(__size);
          for (size_t __i = 0; __i < __size; __i++) {
            auto __element = __result->getElement(__i);
            __vector.push_back(__element->toCpp());
          }
          return __vector;
        }());
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<bool>> JHybridRnIapSpec::deepLinkToSubscriptionsIOS() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>()>("deepLinkToSubscriptionsIOS");
    auto __result = method(_javaPart);
    return [&]() {
      auto __promise = Promise<bool>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<jni::JBoolean>(__boxedResult);
        __promise->resolve(static_cast<bool>(__result->value()));
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<bool>> JHybridRnIapSpec::isEligibleForIntroOfferIOS(const std::string& groupID) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>(jni::alias_ref<jni::JString> /* groupID */)>("isEligibleForIntroOfferIOS");
    auto __result = method(_javaPart, jni::make_jstring(groupID));
    return [&]() {
      auto __promise = Promise<bool>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<jni::JBoolean>(__boxedResult);
        __promise->resolve(static_cast<bool>(__result->value()));
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<std::string>> JHybridRnIapSpec::getReceiptDataIOS() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>()>("getReceiptDataIOS");
    auto __result = method(_javaPart);
    return [&]() {
      auto __promise = Promise<std::string>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<jni::JString>(__boxedResult);
        __promise->resolve(__result->toStdString());
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<std::string>> JHybridRnIapSpec::getReceiptIOS() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>()>("getReceiptIOS");
    auto __result = method(_javaPart);
    return [&]() {
      auto __promise = Promise<std::string>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<jni::JString>(__boxedResult);
        __promise->resolve(__result->toStdString());
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<std::string>> JHybridRnIapSpec::requestReceiptRefreshIOS() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>()>("requestReceiptRefreshIOS");
    auto __result = method(_javaPart);
    return [&]() {
      auto __promise = Promise<std::string>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<jni::JString>(__boxedResult);
        __promise->resolve(__result->toStdString());
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<bool>> JHybridRnIapSpec::isTransactionVerifiedIOS(const std::string& sku) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>(jni::alias_ref<jni::JString> /* sku */)>("isTransactionVerifiedIOS");
    auto __result = method(_javaPart, jni::make_jstring(sku));
    return [&]() {
      auto __promise = Promise<bool>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<jni::JBoolean>(__boxedResult);
        __promise->resolve(static_cast<bool>(__result->value()));
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<std::optional<std::string>>> JHybridRnIapSpec::getTransactionJwsIOS(const std::string& sku) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>(jni::alias_ref<jni::JString> /* sku */)>("getTransactionJwsIOS");
    auto __result = method(_javaPart, jni::make_jstring(sku));
    return [&]() {
      auto __promise = Promise<std::optional<std::string>>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<jni::JString>(__boxedResult);
        __promise->resolve(__result != nullptr ? std::make_optional(__result->toStdString()) : std::nullopt);
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>>> JHybridRnIapSpec::validateReceipt(const NitroReceiptValidationParams& params) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>(jni::alias_ref<JNitroReceiptValidationParams> /* params */)>("validateReceipt");
    auto __result = method(_javaPart, JNitroReceiptValidationParams::fromCpp(params));
    return [&]() {
      auto __promise = Promise<std::variant<NitroReceiptValidationResultIOS, NitroReceiptValidationResultAndroid>>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<JVariant_NitroReceiptValidationResultIOS_NitroReceiptValidationResultAndroid>(__boxedResult);
        __promise->resolve(__result->toCpp());
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<NitroVerifyPurchaseWithProviderResult>> JHybridRnIapSpec::verifyPurchaseWithProvider(const NitroVerifyPurchaseWithProviderProps& params) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>(jni::alias_ref<JNitroVerifyPurchaseWithProviderProps> /* params */)>("verifyPurchaseWithProvider");
    auto __result = method(_javaPart, JNitroVerifyPurchaseWithProviderProps::fromCpp(params));
    return [&]() {
      auto __promise = Promise<NitroVerifyPurchaseWithProviderResult>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<JNitroVerifyPurchaseWithProviderResult>(__boxedResult);
        __promise->resolve(__result->toCpp());
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<std::string>> JHybridRnIapSpec::getStorefront() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>()>("getStorefront");
    auto __result = method(_javaPart);
    return [&]() {
      auto __promise = Promise<std::string>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<jni::JString>(__boxedResult);
        __promise->resolve(__result->toStdString());
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<void>> JHybridRnIapSpec::deepLinkToSubscriptionsAndroid(const NitroDeepLinkOptionsAndroid& options) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>(jni::alias_ref<JNitroDeepLinkOptionsAndroid> /* options */)>("deepLinkToSubscriptionsAndroid");
    auto __result = method(_javaPart, JNitroDeepLinkOptionsAndroid::fromCpp(options));
    return [&]() {
      auto __promise = Promise<void>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& /* unit */) {
        __promise->resolve();
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<bool>> JHybridRnIapSpec::checkAlternativeBillingAvailabilityAndroid() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>()>("checkAlternativeBillingAvailabilityAndroid");
    auto __result = method(_javaPart);
    return [&]() {
      auto __promise = Promise<bool>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<jni::JBoolean>(__boxedResult);
        __promise->resolve(static_cast<bool>(__result->value()));
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<bool>> JHybridRnIapSpec::showAlternativeBillingDialogAndroid() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>()>("showAlternativeBillingDialogAndroid");
    auto __result = method(_javaPart);
    return [&]() {
      auto __promise = Promise<bool>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<jni::JBoolean>(__boxedResult);
        __promise->resolve(static_cast<bool>(__result->value()));
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<std::optional<std::string>>> JHybridRnIapSpec::createAlternativeBillingTokenAndroid(const std::optional<std::string>& sku) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>(jni::alias_ref<jni::JString> /* sku */)>("createAlternativeBillingTokenAndroid");
    auto __result = method(_javaPart, sku.has_value() ? jni::make_jstring(sku.value()) : nullptr);
    return [&]() {
      auto __promise = Promise<std::optional<std::string>>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<jni::JString>(__boxedResult);
        __promise->resolve(__result != nullptr ? std::make_optional(__result->toStdString()) : std::nullopt);
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  void JHybridRnIapSpec::addUserChoiceBillingListenerAndroid(const std::function<void(const UserChoiceBillingDetails& /* details */)>& listener) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JFunc_void_UserChoiceBillingDetails::javaobject> /* listener */)>("addUserChoiceBillingListenerAndroid_cxx");
    method(_javaPart, JFunc_void_UserChoiceBillingDetails_cxx::fromCpp(listener));
  }
  void JHybridRnIapSpec::removeUserChoiceBillingListenerAndroid(const std::function<void(const UserChoiceBillingDetails& /* details */)>& listener) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JFunc_void_UserChoiceBillingDetails::javaobject> /* listener */)>("removeUserChoiceBillingListenerAndroid_cxx");
    method(_javaPart, JFunc_void_UserChoiceBillingDetails_cxx::fromCpp(listener));
  }
  void JHybridRnIapSpec::addDeveloperProvidedBillingListenerAndroid(const std::function<void(const DeveloperProvidedBillingDetailsAndroid& /* details */)>& listener) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JFunc_void_DeveloperProvidedBillingDetailsAndroid::javaobject> /* listener */)>("addDeveloperProvidedBillingListenerAndroid_cxx");
    method(_javaPart, JFunc_void_DeveloperProvidedBillingDetailsAndroid_cxx::fromCpp(listener));
  }
  void JHybridRnIapSpec::removeDeveloperProvidedBillingListenerAndroid(const std::function<void(const DeveloperProvidedBillingDetailsAndroid& /* details */)>& listener) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JFunc_void_DeveloperProvidedBillingDetailsAndroid::javaobject> /* listener */)>("removeDeveloperProvidedBillingListenerAndroid_cxx");
    method(_javaPart, JFunc_void_DeveloperProvidedBillingDetailsAndroid_cxx::fromCpp(listener));
  }
  void JHybridRnIapSpec::enableBillingProgramAndroid(BillingProgramAndroid program) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JBillingProgramAndroid> /* program */)>("enableBillingProgramAndroid");
    method(_javaPart, JBillingProgramAndroid::fromCpp(program));
  }
  std::shared_ptr<Promise<NitroBillingProgramAvailabilityResultAndroid>> JHybridRnIapSpec::isBillingProgramAvailableAndroid(BillingProgramAndroid program) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>(jni::alias_ref<JBillingProgramAndroid> /* program */)>("isBillingProgramAvailableAndroid");
    auto __result = method(_javaPart, JBillingProgramAndroid::fromCpp(program));
    return [&]() {
      auto __promise = Promise<NitroBillingProgramAvailabilityResultAndroid>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<JNitroBillingProgramAvailabilityResultAndroid>(__boxedResult);
        __promise->resolve(__result->toCpp());
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<NitroBillingProgramReportingDetailsAndroid>> JHybridRnIapSpec::createBillingProgramReportingDetailsAndroid(BillingProgramAndroid program) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>(jni::alias_ref<JBillingProgramAndroid> /* program */)>("createBillingProgramReportingDetailsAndroid");
    auto __result = method(_javaPart, JBillingProgramAndroid::fromCpp(program));
    return [&]() {
      auto __promise = Promise<NitroBillingProgramReportingDetailsAndroid>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<JNitroBillingProgramReportingDetailsAndroid>(__boxedResult);
        __promise->resolve(__result->toCpp());
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<bool>> JHybridRnIapSpec::launchExternalLinkAndroid(const NitroLaunchExternalLinkParamsAndroid& params) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>(jni::alias_ref<JNitroLaunchExternalLinkParamsAndroid> /* params */)>("launchExternalLinkAndroid");
    auto __result = method(_javaPart, JNitroLaunchExternalLinkParamsAndroid::fromCpp(params));
    return [&]() {
      auto __promise = Promise<bool>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<jni::JBoolean>(__boxedResult);
        __promise->resolve(static_cast<bool>(__result->value()));
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<bool>> JHybridRnIapSpec::canPresentExternalPurchaseNoticeIOS() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>()>("canPresentExternalPurchaseNoticeIOS");
    auto __result = method(_javaPart);
    return [&]() {
      auto __promise = Promise<bool>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<jni::JBoolean>(__boxedResult);
        __promise->resolve(static_cast<bool>(__result->value()));
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<ExternalPurchaseNoticeResultIOS>> JHybridRnIapSpec::presentExternalPurchaseNoticeSheetIOS() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>()>("presentExternalPurchaseNoticeSheetIOS");
    auto __result = method(_javaPart);
    return [&]() {
      auto __promise = Promise<ExternalPurchaseNoticeResultIOS>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<JExternalPurchaseNoticeResultIOS>(__boxedResult);
        __promise->resolve(__result->toCpp());
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }
  std::shared_ptr<Promise<ExternalPurchaseLinkResultIOS>> JHybridRnIapSpec::presentExternalPurchaseLinkIOS(const std::string& url) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JPromise::javaobject>(jni::alias_ref<jni::JString> /* url */)>("presentExternalPurchaseLinkIOS");
    auto __result = method(_javaPart, jni::make_jstring(url));
    return [&]() {
      auto __promise = Promise<ExternalPurchaseLinkResultIOS>::create();
      __result->cthis()->addOnResolvedListener([=](const jni::alias_ref<jni::JObject>& __boxedResult) {
        auto __result = jni::static_ref_cast<JExternalPurchaseLinkResultIOS>(__boxedResult);
        __promise->resolve(__result->toCpp());
      });
      __result->cthis()->addOnRejectedListener([=](const jni::alias_ref<jni::JThrowable>& __throwable) {
        jni::JniException __jniError(__throwable);
        __promise->reject(std::make_exception_ptr(__jniError));
      });
      return __promise;
    }();
  }

} // namespace margelo::nitro::iap
