///
/// NitroReceiptValidationResultAndroid.swift
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2026 Marc Rousavy @ Margelo
///

import NitroModules

/**
 * Represents an instance of `NitroReceiptValidationResultAndroid`, backed by a C++ struct.
 */
public typealias NitroReceiptValidationResultAndroid = margelo.nitro.iap.NitroReceiptValidationResultAndroid

public extension NitroReceiptValidationResultAndroid {
  private typealias bridge = margelo.nitro.iap.bridge.swift

  /**
   * Create a new instance of `NitroReceiptValidationResultAndroid`.
   */
  init(autoRenewing: Bool, betaProduct: Bool, cancelDate: Double?, cancelReason: String?, deferredDate: Double?, deferredSku: String?, freeTrialEndDate: Double, gracePeriodEndDate: Double, parentProductId: String, productId: String, productType: String, purchaseDate: Double, quantity: Double, receiptId: String, renewalDate: Double, term: String, termSku: String, testTransaction: Bool) {
    self.init(autoRenewing, betaProduct, { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = cancelDate {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_std__string_ in
      if let __unwrappedValue = cancelReason {
        return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_double_ in
      if let __unwrappedValue = deferredDate {
        return bridge.create_std__optional_double_(__unwrappedValue)
      } else {
        return .init()
      }
    }(), { () -> bridge.std__optional_std__string_ in
      if let __unwrappedValue = deferredSku {
        return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
      } else {
        return .init()
      }
    }(), freeTrialEndDate, gracePeriodEndDate, std.string(parentProductId), std.string(productId), std.string(productType), purchaseDate, quantity, std.string(receiptId), renewalDate, std.string(term), std.string(termSku), testTransaction)
  }

  var autoRenewing: Bool {
    @inline(__always)
    get {
      return self.__autoRenewing
    }
    @inline(__always)
    set {
      self.__autoRenewing = newValue
    }
  }
  
  var betaProduct: Bool {
    @inline(__always)
    get {
      return self.__betaProduct
    }
    @inline(__always)
    set {
      self.__betaProduct = newValue
    }
  }
  
  var cancelDate: Double? {
    @inline(__always)
    get {
      return self.__cancelDate.value
    }
    @inline(__always)
    set {
      self.__cancelDate = { () -> bridge.std__optional_double_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_double_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var cancelReason: String? {
    @inline(__always)
    get {
      return { () -> String? in
        if bridge.has_value_std__optional_std__string_(self.__cancelReason) {
          let __unwrapped = bridge.get_std__optional_std__string_(self.__cancelReason)
          return String(__unwrapped)
        } else {
          return nil
        }
      }()
    }
    @inline(__always)
    set {
      self.__cancelReason = { () -> bridge.std__optional_std__string_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
        } else {
          return .init()
        }
      }()
    }
  }
  
  var deferredDate: Double? {
    @inline(__always)
    get {
      return self.__deferredDate.value
    }
    @inline(__always)
    set {
      self.__deferredDate = { () -> bridge.std__optional_double_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_double_(__unwrappedValue)
        } else {
          return .init()
        }
      }()
    }
  }
  
  var deferredSku: String? {
    @inline(__always)
    get {
      return { () -> String? in
        if bridge.has_value_std__optional_std__string_(self.__deferredSku) {
          let __unwrapped = bridge.get_std__optional_std__string_(self.__deferredSku)
          return String(__unwrapped)
        } else {
          return nil
        }
      }()
    }
    @inline(__always)
    set {
      self.__deferredSku = { () -> bridge.std__optional_std__string_ in
        if let __unwrappedValue = newValue {
          return bridge.create_std__optional_std__string_(std.string(__unwrappedValue))
        } else {
          return .init()
        }
      }()
    }
  }
  
  var freeTrialEndDate: Double {
    @inline(__always)
    get {
      return self.__freeTrialEndDate
    }
    @inline(__always)
    set {
      self.__freeTrialEndDate = newValue
    }
  }
  
  var gracePeriodEndDate: Double {
    @inline(__always)
    get {
      return self.__gracePeriodEndDate
    }
    @inline(__always)
    set {
      self.__gracePeriodEndDate = newValue
    }
  }
  
  var parentProductId: String {
    @inline(__always)
    get {
      return String(self.__parentProductId)
    }
    @inline(__always)
    set {
      self.__parentProductId = std.string(newValue)
    }
  }
  
  var productId: String {
    @inline(__always)
    get {
      return String(self.__productId)
    }
    @inline(__always)
    set {
      self.__productId = std.string(newValue)
    }
  }
  
  var productType: String {
    @inline(__always)
    get {
      return String(self.__productType)
    }
    @inline(__always)
    set {
      self.__productType = std.string(newValue)
    }
  }
  
  var purchaseDate: Double {
    @inline(__always)
    get {
      return self.__purchaseDate
    }
    @inline(__always)
    set {
      self.__purchaseDate = newValue
    }
  }
  
  var quantity: Double {
    @inline(__always)
    get {
      return self.__quantity
    }
    @inline(__always)
    set {
      self.__quantity = newValue
    }
  }
  
  var receiptId: String {
    @inline(__always)
    get {
      return String(self.__receiptId)
    }
    @inline(__always)
    set {
      self.__receiptId = std.string(newValue)
    }
  }
  
  var renewalDate: Double {
    @inline(__always)
    get {
      return self.__renewalDate
    }
    @inline(__always)
    set {
      self.__renewalDate = newValue
    }
  }
  
  var term: String {
    @inline(__always)
    get {
      return String(self.__term)
    }
    @inline(__always)
    set {
      self.__term = std.string(newValue)
    }
  }
  
  var termSku: String {
    @inline(__always)
    get {
      return String(self.__termSku)
    }
    @inline(__always)
    set {
      self.__termSku = std.string(newValue)
    }
  }
  
  var testTransaction: Bool {
    @inline(__always)
    get {
      return self.__testTransaction
    }
    @inline(__always)
    set {
      self.__testTransaction = newValue
    }
  }
}
